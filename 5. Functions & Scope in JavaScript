1. What is a Function?
A function is a reusable block of code designed to perform a specific task.
        function greet(name) {
          return `Hello, ${name}`;
        }

It can:
* Take input (parameters)
* Return output (return)
* Be stored, passed, or invoked like any other value (JS treats functions as first-class citizens)

2. Ways to Declare a Function:
A. Function Declaration (aka Plain or Regular Function):
        function add(a, b) {
          return a + b;
        }

* Hoisted
* Has its own this
* Can be called before its declaration

B. Function Expression:
        const add = function(a, b) {
          return a + b;
        };

* Not hoisted (variable is hoisted but not assigned)
* Useful for anonymous functions
* Can be stored in variables or passed to other functions

C. Arrow Function (ES6+):
        const add = (a, b) => a + b;

* Cleaner, shorter syntax, but with different behavior for this, arguments, etc.

3. Detailed Comparison: Plain vs Arrow Functions:

| Feature                | Plain Function              |   Arrow Function                  |
| ---------------------- | --------------------------- | --------------------------------- |
|     Syntax             | function()                  |     ()=>                          |
|     `this` binding     | Own `this`                  |   Lexical (inherits from parent)  |
|     `arguments` object | Available                   |   Not available                   |
|     `new` keyword      | Can be used as constructor  |   Cannot be used as constructor   |
|     Hoisting           | ‚úÖ Yes                      |   No                              |
|     Prototype          | Has .prototype              |     No .prototype                 |
|     Use cases          | Complex logic, constructors |   Callbacks, one-liners, closures |


-> this Keyword:
A. Plain Function (this is dynamic)
        const person = {
          name: 'Prakhar',
          greet: function() {
            console.log(this.name);
          }
        };
        
        person.greet(); // "Prakhar"

B. Arrow Function (this is lexical ‚Äî inherits from surrounding scope):
        const person = {
          name: 'Prakhar',
          greet: () => {
            console.log(this.name);  // undefined
          }
        };

**NOTE: Arrow functions do not have their own this ‚Äî useful for callbacks, not object methods.

4. Using arguments object:
        function sum() {
          console.log(arguments);  // array-like object
        }
        
        sum(1, 2, 3);

* Plain function has access to arguments
* Arrow function does not
        const sum = () => {
          console.log(arguments); // ‚ùå ReferenceError
        };

# Use rest parameters in arrow functions:
        const sum = (...args) => args.reduce((a, b) => a + b, 0);

5. Returning Values:
A. Regular Function
        function square(x) {
          return x * x;
        }

B. Arrow Function (Single-line implicit return)
        const square = x => x * x;

For multiple lines, use {} with return explicitly:
        const square = x => {
          const result = x * x;
          return result;
        };

6. Can Arrow Functions Be Constructors?
No. Arrow functions cannot be used with new
        const Person = (name) => {
          this.name = name;
        };
        
        const p = new Person("Prakhar"); // ‚ùå TypeError


7. Function Hoisting:
        hello(); // ‚úÖ works
        function hello() {
          console.log("Hi");
        }
        
        arrow(); // ‚ùå ReferenceError
        const arrow = () => console.log("Arrow");

* Function declarations are hoisted entirely
* Arrow functions (function expressions) are not hoisted ‚Äî the variable is hoisted as undefined

üåê 8. Scope in JavaScript
| Scope Type           | Where it exists              |
| -------------------- | ---------------------------- |
|     Global           | Outside all functions/blocks |
|     Function (local) | Inside functions             |
|     Block (ES6)      | `let`/`const` inside `{}`    |

        let x = 10;
        
        function test() {
          let x = 20;
          console.log(x); // 20
        }
        test();
        console.log(x); // 10

üöß 9. Closures (Interview Favorite!):
A closure is when a function "remembers" its lexical scope, even when executed outside it.
        function outer() {
          let count = 0;
          return function inner() {
            count++;
            console.log(count);
          };
        }
        
        const counter = outer();
        counter(); // 1
        counter(); // 2

inner() still has access to count because it closes over outer()'s scope

üî• 10. Common Interview Traps
| Concept                       | Gotcha                                 |
| ----------------------------- | -------------------------------------- |
| `this` in arrow function      | Inherits from outer scope              |
| `arguments` in arrow function | Not available                          |
| Constructor with arrow        | ‚ùå Can't use `new`                      |
| Arrow inside method           | Can‚Äôt use `this` correctly             |
| Hoisting                      | Only function declarations hoist fully |

Example Exercise (Great for Interviews)
        const obj = {
          value: 42,
          regular: function() {
            console.log("regular:", this.value);
          },
          arrow: () => {
            console.log("arrow:", this.value);
          }
        };
        
        obj.regular(); // 42 ‚úÖ
        obj.arrow();   // undefined ‚ùå
