# PART 1: Object Cloning in JavaScript
      Q. What is Object Cloning?
      Cloning an object means creating a new object that has the same structure and values as the original.
      
      There are two types of cloning:
      > Shallow Cloning â†’ Only top-level properties are copied
      > Deep Cloning â†’ Nested objects are also cloned recursively
      
      1. Why Cloning is Tricky in JavaScript
      JS objects are stored by reference (i.e., memory address). So:
            const obj1 = { name: 'Prakhar' };
            const obj2 = obj1;
            
            obj2.name = 'Rahul';
            
            console.log(obj1.name); // ðŸ”´ 'Rahul'
      
      Both obj1 and obj2 point to the same object in memory.
      
      2. Shallow Cloning â€” Methods & Pitfalls
      a) Method 1: Object.assign({}, source)
            const source = { name: 'JS' };
            const clone = Object.assign({}, source);
      
      b) Method 2: Spread Operator { ...obj }
            const source = { name: 'JS' };
            const clone = { ...source };
      
      
      These both:
      * Clone top-level keys
      * But don't clone nested objects
      
      Example: Shallow Copy Pitfall
            const user = {
              name: 'Prakhar',
              address: {
                city: 'Delhi'
              }
            };
            
            const copy = { ...user };
            copy.address.city = 'Mumbai';
            
            console.log(user.address.city); // â— 'Mumbai' 
      
      Even though we cloned user, the address object is still shared.
      
      3. Deep Cloning â€” Techniques
      1> Method 1: structuredClone() (modern JS)
            const deepClone = structuredClone(originalObject);
      
      -> Works with:
      * Nested objects
      * Dates
      * Arrays
      * Sets, Maps
      * Circular references
      
      2> Method 2: JSON.parse(JSON.stringify(obj))
            const deepCopy = JSON.parse(JSON.stringify(obj));
      
      Limitations:
      âŒ Drops functions
      âŒ Converts Date to string
      âŒ Removes undefined, Infinity, NaN
      âŒ Crashes on circular references
      
      3> Method 3: Manual Recursive Cloning
            function deepClone(obj) {
              if (obj === null || typeof obj !== 'object') return obj;
            
              const result = Array.isArray(obj) ? [] : {};
            
              for (let key in obj) {
                result[key] = deepClone(obj[key]);
              }
            
              return result;
            }
      
      * Good for understanding how recursion works
      * Can be customized to handle Date, RegExp, etc.
      
      4. Handling Circular References
      Q. What are Circular References?
            const obj = {};
            obj.self = obj; // ðŸ‘ˆ refers to itself
      
      This will crash JSON.stringify():
            JSON.stringify(obj); // âŒ TypeError: Converting circular structure to JSON
      
      But works with structuredClone()
      
      5. Object.freeze() vs Object.seal()
      Object.freeze(obj)
      * Makes object immutable
      * Cannot add / delete / change props
      
            const obj = Object.freeze({ a: 1 });
            obj.a = 2;         // ignored in non-strict, error in strict
            obj.b = 3;         // ignored
            delete obj.a;      // ignored
      
      Object.seal(obj)
      * Cannot add or delete props
      * But can modify existing props
      
            const obj = Object.seal({ a: 1 });
            obj.a = 2;         // âœ… works
            obj.b = 3;         // âŒ no new props
      
      6. Summary Cloning Methods
      | Method                         | Shallow/Deep | Supports circular?    | Notes                        |
      | ------------------------------ | ------------ | --------------------- | ---------------------------- |
      | `{ ...obj }`                   | Shallow      | âŒ                   | Fast, simple                 |
      | `Object.assign()`              | Shallow      | âŒ                   | Same as above                |
      | `JSON.parse(JSON.stringify())` | Deep         | âŒ                   | Drops functions, `undefined` |
      | `structuredClone()`            | Deep         | âœ…                   | Modern, ideal                |
      | Custom Recursive Clone         | Deep         | âœ… (if WeakMap used) | Best for fine control        |

PART 2: JavaScript Garbage Collector (GC)
      Q. What is Garbage Collection?
      JS uses automatic garbage collection to free memory occupied by values no longer in use.
      You donâ€™t need to free() or delete memory like in C/C++ â€” JS does it for you, via the Garbage Collector.
      
      1. How JS Memory Works
      > Stack vs Heap
      | Memory Type | Used For                         |
      | ----------- | -------------------------------- |
      | **Stack**   | Primitive values, function calls |
      | **Heap**    | Objects, arrays, closures, etc   |
      
            let a = 5; // in stack
            let obj = { x: 1 }; // obj in stack holds pointer to heap
      
      2. How GC Decides What to Collect?
      Most modern JS engines use:
      * Mark-and-Sweep Algorithm
      
      Mark & Sweep Steps:
      * Mark all roots (global, local variables)
      * Traverse references, mark reachable objects
      * Collect all unmarked objects
      
            function outer() {
              let a = { value: 42 }; // reachable
              let b = { value: 99 }; // becomes unreachable
              b = null;              // âŒ now b is not referenced
            }
      At the end, b is garbage collected.
      
      3. Common GC-Related Mistakes
      ** 1. Global Variables Never Die
            var x = {}; // remains in memory until page unload
      
      ** 2. Memory Leaks in Closures
            function leaky() {
              let bigData = new Array(1e6).fill('leak');
              return () => console.log(bigData[0]);
            }
            const hold = leaky(); // bigData still lives!
      
      GC cannot clean bigData because itâ€™s closed over by the inner function.
      
      4. Circular References are OK (if not reachable)
      Contrary to belief, circular references donâ€™t cause memory leaks unless still accessible:
            function cycle() {
              let obj1 = {};
              let obj2 = {};
              obj1.ref = obj2;
              obj2.ref = obj1;
            }
            
            cycle(); // âœ… Both collected, as they're not globally referenced
      
      5. WeakMap & WeakSet (GC Friendly)
      These collections hold weak references, meaning they donâ€™t prevent GC.
            let obj = { name: "Prakhar" };
            const weakMap = new WeakMap();
            
            weakMap.set(obj, "value");
            
            obj = null; // âœ… can be garbage collected
      
      Used in:
      * Caching
      * Memoization
      * Avoiding leaks
